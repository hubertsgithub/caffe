import sys
import threading
from datetime import datetime
from Queue import Queue
from lib.utils.misc.pathresolver import acrp
from google import protobuf
from google.protobuf.text_format import ParseError

# Make sure that caffe is on the python path:
sys.path.append(acrp('python'))
from caffe.proto import caffe_pb2

def freadlines(filepath, strip=True):
    with open(filepath, 'r') as f:
        if strip:
            lines = [s.strip() for s in f.readlines()]
        else:
            lines = f.readlines()

    return lines


def fwritelines(filepath, lines, endline=True):
    with open(filepath, 'w') as f:
        for l in lines:
            if endline:
                l = '{0}\n'.format(l)

            f.write(l)


def parse_solver_file(filepath):
    '''
    Returns a protobuf object with the solver parameters
    '''
    lines = freadlines(filepath)
    solver_params = caffe_pb2.SolverParameter()
    protobuf.text_format.Merge('\n'.join(lines), solver_params)

    return solver_params


def save_solver_file(filepath, solver_params):
    '''
    Saves a solver file using the specified parameters
    '''
    with open(filepath, 'w') as f:
        f.write('# GENERATED BY TRAINER.PY {0}\n'.format(datetime.now()))
        f.write(protobuf.text_format.MessageToString(solver_params))


def parse_model_definition_file(filepath):
    '''
    Parse protobuf file
    '''
    lines = freadlines(filepath)
    model_params = caffe_pb2.NetParameter()
    protobuf.text_format.Merge('\n'.join(lines), model_params)

    return model_params


class AsynchronousFileReader(threading.Thread):
    '''
    Helper class to implement asynchronous reading of a file
    in a separate thread. Pushes read lines on a queue to
    be consumed in another thread.
    '''

    def __init__(self, fd, queue):
        assert isinstance(queue, Queue)
        assert callable(fd.readline)
        threading.Thread.__init__(self)
        self._fd = fd
        self._queue = queue

    def run(self):
        '''The body of the tread: read lines and put them on the queue.'''
        for line in iter(self._fd.readline, ''):
            self._queue.put(line)

    def eof(self):
        '''Check whether there is no more content to expect.'''
        return not self.is_alive() and self._queue.empty()
